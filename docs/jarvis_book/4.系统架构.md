# 4. 系统架构

本章将深入探讨 Jarvis 的系统架构，解释其主要组件如何协同工作，以及数据和控制流如何在系统中传递。

## 4.1 架构概述

Jarvis 采用了一种高度模块化和可插拔的架构，旨在实现最大的灵活性和可扩展性。其核心围绕着“代理-工具-平台”这一范式构建。

下面是一个简化的架构图，展示了系统的主要组成部分及其相互关系：

```
+-------------------------------------------------------------------------+
|                                User Input                               |
+-------------------------------------------------------------------------+
             |
             v
+-------------------------------------------------------------------------+
|                           Command Line Interface (CLI)                  |
|      (e.g., jvs, jca, jpm) - Entry Point & Task Dispatcher              |
+-------------------------------------------------------------------------+
             |
             v
+-------------------------------------------------------------------------+
|                                  Agent Core                             |
|  (Task Planning, Reasoning, State Management, Methodology Engine)       |
+------------------------+--------------------------+---------------------+
             |                      |                     |
             |                      |                     |
+----------------v------------------+-----------------v-------------------+
|      Tool Registry & Executor     |       Platform Registry & Manager     |
|   (Loads and executes tools)      |  (Manages LLM platform abstractions)  |
+----------------+------------------+-----------------+-------------------+
                 |                                    |
        +--------+--------+                           |
        |                 |                           |
        v                 v                           v
+-----------------+  +------------------+  +--------------------------------+
|  Built-in Tools |  |  Custom Tools    |  |       LLM Platform API         |
| (edit_file, etc)|  | (~/.jarvis/tools)|  | (yuanbao, kimi, openai, etc.)  |
+-----------------+  +------------------+  +--------------------------------+
        |                 |                           |
        |                 |                           |
        v                 v                           v
+-------------------------------------------------------------------------+
|                              External World                             |
|            (File System, Shell, Web, APIs, Databases, etc.)             |
+-------------------------------------------------------------------------+

```

## 4.2 组件详解

### 1. 命令行接口 (CLI)
-   **职责**: 作为用户与 Jarvis 交互的入口。它负责解析命令行参数，初始化环境，并将用户的初始任务分派给相应的代理。
-   **实现**: `jarvis`, `jca`, `jpm` 等都是不同的CLI入口，它们各自加载预设的配置和特定的代理。

### 2. 代理核心 (Agent Core)
-   **职责**: 这是 Jarvis 的“决策中心”。它接收来自CLI的任务，然后进行一系列的智能处理：
    -   **任务规划**: 将模糊的用户请求分解为清晰、可执行的步骤。
    -   **推理**: 基于当前状态和目标，决定下一步应该调用哪个工具。
    -   **方法论引擎**: （可选）在规划前，先生成一个解决问题的宏观策略（方法论）。
    -   **状态管理**: 跟踪任务的完整上下文，包括历史记录、文件变更和用户反馈。
-   **交互**: 代理核心通过与工具注册表和平台注册表交互来执行其计划。

### 3. 工具注册表与执行器 (Tool Registry & Executor)
-   **职责**: 负责发现、加载和执行工具。
-   **加载机制**: 系统启动时，会自动扫描内置的工具目录和用户自定义的工具目录 (`~/.jarvis/tools/`)，将所有合法的工具加载到一个注册表中。
-   **执行**: 当代理决定使用某个工具时，执行器会根据工具定义的参数规范，将代理提供的参数传递给工具的 `execute` 方法，并捕获其输出（stdout, stderr）和成功状态。

### 4. 平台注册表与管理器 (Platform Registry & Manager)
-   **职责**: 统一管理所有可用的大模型平台（LLM Platforms）。
-   **加载机制**: 与工具类似，平台注册表会自动发现并加载所有内置和自定义的平台实现 (`~/.jarvis/platforms/`)。
-   **抽象接口**: 它为代理提供了一个统一的 `chat` 接口。代理无需关心底层调用的是哪个平台的API，只需将需要LLM处理的文本（如生成代码、分析问题）发送给平台管理器即可。

### 5. 外部世界 (External World)
-   **职责**: 这是 Jarvis 执行操作的实际环境，包括本地文件系统、操作系统的Shell、互联网、外部API等。
-   **交互方式**: Jarvis 只能通过**工具**来与外部世界交互。这种设计确保了所有操作都是明确、可控和可记录的。

## 4.3 数据流与控制流

1.  **启动**: 用户通过 CLI 发起一个任务，例如 `jca -r "在 a.py 中添加一个新函数"`。
2.  **分派**: CLI 将任务“在 a.py 中添加一个新函数”传递给代码代理（Code Agent）。
3.  **思考与规划**:
    -   代理将任务发送给通过**平台管理器**选择的LLM，请求一个执行计划。
    -   LLM 返回一个计划，可能是：“1. 使用 `read_code` 工具读取 `a.py` 的内容。 2. 分析内容并生成新函数。 3. 使用 `edit_file` 工具将新函数插入文件。”
4.  **执行**:
    -   代理调用**工具执行器**，执行 `read_code(path='a.py')`。
    -   工具与**外部世界**（文件系统）交互，返回文件内容。
5.  **再思考**:
    -   代理将文件内容和原始需求再次发送给**平台管理器**，请求生成具体的代码。
    -   LLM 返回生成的函数代码。
6.  **再执行**:
    -   代理调用**工具执行器**，执行 `edit_file`，将代码插入 `a.py`。
    -   工具与**外部世界**交互，完成文件修改。
7.  **总结**: 代理确认任务完成，向用户报告结果。

在整个过程中，如果需要用户确认或输入，代理会通过 `ask_user` 工具暂停流程，等待用户的响应。这种“思考-行动”的循环是 Jarvis 工作的核心模式。
