# 3. 核心概念

要深入了解并有效使用 Jarvis，理解其背后的几个核心概念至关重要。本章将通过文字描述和关键代码摘录，介绍构成 Jarvis 系统的五大基石：**代理（Agent）**、**工具(Tool)**、**平台(Platform)**、**模型(Model)**和**方法论（Methodology）**。

## 3.1 代理 (Agent)

**代理(Agent)** 是 Jarvis 的“大脑”和执行中枢，一个高度灵活的**协调者和调度者**。它本身不包含复杂的业务逻辑，而是通过一个**主循环**来驱动整个工作流：获取能力、请求决策、委托执行、循环迭代。

Agent 的核心设计思想是**委托（Delegation）**。它将具体的执行逻辑（如工具调用、文件编辑）委托给不同的**输出处理器(Output Handler)**。这使得 Agent 的核心与具体能力完全解耦。

#### 关键代码示例

`jarvis_agent` 的核心 `Agent` 类，在初始化时接收一个 `output_handler` 列表，这从代码层面证实了其委托机制。

```python
# 文件: src/jarvis/jarvis_agent/main.py
# (此为 Agent 类的简化定义，展示核心参数)

class Agent:
    def __init__(
        self,
        # ...
        output_handler: List[OutputHandlerProtocol],
        # ...
    ):
        # ...
```

**代码解读**: `Agent` 并不关心如何处理输出的内容，它只负责将 LLM 的响应依次交给 `output_handler` 列表中的处理器。谁能处理，谁就执行。例如，`ToolRegistry` 就是一个专门处理 `<TOOL_CALL>` 标签的输出处理器。

## 3.2 工具与工具注册表 (Tool & ToolRegistry)

**工具(Tool)** 是 Jarvis 的“双手”，是原子化的、功能单一的可执行单元。

**工具注册表(ToolRegistry)** 是所有工具的管理者。它负责发现、加载和执行工具。根据代码，它通过三种独立的机制来加载工具。

#### 工具加载机制

`ToolRegistry` 的 `__init__` 方法清晰地展示了其工具加载的入口。

```python
# 文件: src/jarvis/jarvis_tools/registry.py

class ToolRegistry:
    def __init__(self) -> None:
        self.tools: Dict[str, Tool] = {}
        # 关键: 三种独立的加载机制
        self._load_builtin_tools()
        self._load_external_tools()
        self._load_mcp_tools()
```

1.  `_load_builtin_tools()`: 从项目内置的 `src/jarvis/tools` 目录加载原生Python工具。
2.  `_load_external_tools()`: 从用户目录（如 `~/.jarvis/tools`）加载用户自己编写的Python工具。
3.  `_load_mcp_tools()`: 通过 **模型通信协议(MCP)** 与外部独立进程通信，来加载该进程提供的工具。MCP是一种基于JSON-RPC的标准化通信协议，是Jarvis实现高级扩展的关键技术。

## 3.3 平台与平台注册表 (Platform & PlatformRegistry)

**平台(Platform)** 是指大语言模型（LLM）的**服务提供商**，例如 OpenAI、Kimi、腾讯元宝等。在 Jarvis 中，它被抽象为一个统一的**接口**，负责处理与特定服务商API的通信、认证和错误处理。

**平台注册表(PlatformRegistry)** 负责加载所有可用的平台实现。它通过扫描目录中的 `.py` 文件来加载**原生Python平台**，确保 Agent 能以一致的方式与不同的 LLM 服务商交互。

#### 关键代码示例

`PlatformRegistry` 通过加载 `BasePlatform` 的子类来集成不同的平台。

```python
# 文件: src/jarvis/jarvis_platform/registry.py

class PlatformRegistry:
    @staticmethod
    def load_platform_from_dir(directory: str) -> Dict[str, Type[BasePlatform]]:
        # ...
        # 关键: 遍历目录下的 .py 文件，并查找 BasePlatform 的子类
        for filename in os.listdir(directory):
            # ...
```

## 3.4 模型 (Model)

**模型(Model)** 是指由**平台**提供的、执行具体思考和文本生成任务的**语言模型引擎**，例如 `gpt-4o`, `moonshot-v1-8k` 等。模型是 Jarvis 智能的核心来源，不同的模型具有不同的能力、成本和使用场景。

平台和模型是**提供者**与**产品**的关系。Jarvis 的设计将两者清晰地分开，允许用户在同一平台下轻松切换不同的模型。

#### 关键代码示例

所有平台都必须实现的 `BasePlatform` 接口中，强制定义了 `set_model_name` 方法，这从代码层面确立了“模型”是一个独立于“平台”的重要概念。

```python
# 文件: src/jarvis/jarvis_platform/base.py

class BasePlatform(ABC):
    # ...
    @abstractmethod
    def set_model_name(self, model_name: str):
        """Set model name"""
        raise NotImplementedError("set_model_name is not implemented")
    # ...
```
**代码解读**: 这段代码从架构上确立了任何平台都必须支持设置具体模型名称。这允许用户通过配置文件（例如 `~/.jarvis/config.yaml`）来指定使用哪个模型，而无需修改代码，实现了模型和平台的分离。

## 3.5 方法论 (Methodology)

**方法论(Methodology)** 是 Jarvis 实现“智能进化”的核心机制。它是一套结构化的、用于指导代理解决问题的“思维框架”或“最佳实践”。它定义了代理在面对任务时应该“如何思考”，从而影响它发送给 LLM 的 Prompt 内容，以产生更优的决策。
