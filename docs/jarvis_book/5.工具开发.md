# 5. 工具开发

Jarvis 的强大之处在于其高度的可扩展性，而**自定义工具**是实现扩展的核心。通过创建自己的工具，您可以让 Jarvis 与您的私有API、内部数据库、专有系统或任何您需要的服务进行交互。

本章将指导您完成创建、测试和部署自定义工具的全过程。Jarvis 支持两种工具集成方式：
1.  **标准工具开发**：通过创建符合规范的 Python 类来定义工具。
2.  **MCP 工具集成**：通过配置文件连接到外部的“多能力提供者”(Multi-Capability Provider)，快速集成用任何语言编写的现有工具集。

---

## 5.1 标准工具开发 (Python 类)

这是最常用、最直接的工具开发方式。

### 工具加载位置

Jarvis 启动时会从以下位置自动扫描并加载工具文件 (`.py`):

1.  **内置工具**: `src/jarvis/jarvis_tools/` (Jarvis 源码内部)
2.  **用户自定义工具**: `~/.jarvis/tools/` (推荐存放您个人工具的地方)
3.  **额外工具目录**: 由 `JARVIS_TOOL_LOAD_DIRS` 环境变量指定的目录列表。这允许您将工具组织在项目的任何位置。

### 工具类的核心规范

一个标准的工具类必须遵循以下规范：

1.  **文件名与工具名匹配 (关键)**: 工具文件名 (不含 `.py` 后缀) **必须**与工具类内部的 `name` 属性完全一致。这是Jarvis能够找到并注册工具的硬性约定。
    -   **正确**: 文件 `my_tool.py` -> 类属性 `name = "my_tool"`
    -   **错误**: 文件 `my_tool.py` -> 类属性 `name = "MyTool"` 或 `name = "some_other_name"`

2.  **类属性**:
    -   `name`: (字符串) 工具的唯一名称，与文件名匹配。
    -   `description`: (字符串) 工具功能的清晰描述。AI会根据这个描述来判断何时使用该工具。
    -   `parameters`: (字典) 定义工具所需参数的 JSON Schema。

3.  **类方法**:
    -   `execute(self, args)`: (方法) 工具的实际执行逻辑。
    -   `check()`: (可选的 `@staticmethod`) 一个静态方法，用于在加载工具前进行前置检查。如果 `check()` 方法存在并且返回 `False`，该工具将被跳过，不会加载。这可以用于检查依赖项是否存在、API密钥是否配置等。

### 开发步骤

让我们创建一个新工具，它能读取 `.ini` 配置文件。

#### 第1步：创建工具文件

根据命名约定，我们想创建一个名为 `read_ini_section` 的工具，所以文件名必须是 `read_ini_section.py`。

在 `~/.jarvis/tools/` 目录下创建 `read_ini_section.py` 文件。

#### 第2步：编写工具类

在 `read_ini_section.py` 文件中，写入以下代码：

```python
import configparser
from typing import Dict, Any

class ReadIniSectionTool:
    # 1. 工具名称 (必须与文件名 "read_ini_section" 匹配)
    name = "read_ini_section"
    
    # 2. 工具描述 (给AI看，必须清晰)
    description = "读取 .ini 格式的配置文件中指定 section 的所有内容。"
    
    # 3. 参数定义 (使用JSON Schema)
    parameters = {
        "type": "object",
        "properties": {
            "file_path": {
                "type": "string",
                "description": "要读取的 .ini 文件的完整路径。"
            },
            "section_name": {
                "type": "string",
                "description": "要读取的配置项所在的 section 名称。"
            }
        },
        "required": ["file_path", "section_name"]
    }

    # 4. (可选) 前置检查
    @staticmethod
    def check() -> bool:
        # 这里的依赖 'configparser' 是标准库，所以我们直接返回 True。
        # 如果你的工具依赖第三方库，可以在这里检查。
        # try:
        #     import some_dependency
        # except ImportError:
        #     print("警告: 'some_dependency' 未安装，'read_ini_section' 工具已禁用。")
        #     return False
        return True

    # 5. 执行逻辑
    def execute(self, args: Dict[str, Any]) -> Dict[str, Any]:
        file_path = args.get("file_path")
        section_name = args.get("section_name")

        try:
            if not file_path or not section_name:
                raise ValueError("错误：必须同时提供 file_path 和 section_name。")

            config = configparser.ConfigParser()
            if not config.read(file_path):
                raise FileNotFoundError(f"错误：配置文件 '{file_path}' 不存在或无法读取。")

            if not config.has_section(section_name):
                raise ValueError(f"错误：在配置文件中未找到名为 '{section_name}' 的 section。")

            section_content = dict(config.items(section_name))
            return {
                "success": True,
                "stdout": str(section_content),
                "stderr": ""
            }
        except Exception as e:
            return {
                "success": False,
                "stdout": "",
                "stderr": f"执行工具时发生错误: {str(e)}"
            }
```

#### 第3步：测试工具

无需额外注册，只需重新启动 `jarvis` (`jvs`)，新工具就会被自动加载。

1.  **检查加载**: 输入 `'ToolUsage'` 查看工具列表，确认 `read_ini_section` 已在其中。
2.  **自然语言测试**: 给 Jarvis 一个任务，例如：`请帮我读取 /path/to/my/app.ini 文件中 [database] section 的内容。`

---

## 5.2 MCP 工具集成

MCP (Multi-Capability Provider) 是一种强大的机制，允许 Jarvis 通过标准输入/输出 (stdio) 或 HTTP 等方式与外部工具集进行通信。这意味着您可以用任何语言（如 Go, Rust, Node.js）编写工具，并将它们作为一个整体接入 Jarvis。

### 配置方法

MCP 工具通过 `JARVIS_MCP` 环境变量进行配置。这是一个包含 MCP 客户端配置的列表。

下面是一个通过 `stdio` 连接到外部工具程序的示例配置：

```yaml
# 在你的 Jarvis 配置文件 (如 ~/.jarvis/config.yaml) 中
JARVIS_MCP:
  - type: stdio       # 连接类型，stdio表示通过标准输入输出
    name: "my_cli"      # 为这组MCP工具命一个名
    command: "/path/to/your/tool_program" # 启动工具程序的命令
    enable: true      # 是否启用
```

### MCP 工具工作流程

1.  Jarvis 启动时，会根据 `command` 运行你的工具程序。
2.  Jarvis 通过 `stdin` 向你的程序发送 JSON-RPC 请求，例如查询工具列表 (`get_tool_list`) 或执行工具 (`execute`)。
3.  你的程序处理请求，并通过 `stdout` 将 JSON-RPC 响应发送回 Jarvis。
4.  Jarvis 解析响应，并将 `my_cli` 提供的所有工具注册到系统中，使其可以像标准工具一样被AI调用。

这种方式非常适合将现有的、复杂的命令行工具或微服务快速集成到 Jarvis 中。

---

## 5.3 最佳实践

-   **命名约定是关键**: 务必遵守**文件名与 `name` 属性匹配**的规则，这是最常见的工具加载失败原因。
-   **保持原子性**: 每个工具应该只做一件事，并把它做好。复杂的逻辑应该拆分为多个工具。
-   **描述要清晰**: `description` 是写给 AI 看的，是决定工具能否被正确使用的最关键因素。
-   **健壮的错误处理**: `execute` 方法必须能妥善处理错误，并通过 `stderr` 返回有意义的错误信息。
-   **精确的参数定义**: `parameters` 定义要尽可能精确。使用 `description` 字段详细解释每个参数。
-   **返回值为字符串**: `stdout` 和 `stderr` 字段应该是字符串。如果结果是复杂数据结构，请将其序列化为字符串（如 `json.dumps()`）。
